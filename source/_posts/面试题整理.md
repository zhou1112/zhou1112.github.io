---
title: 面试题整理
tags: 
 - 面试题
---

![avatar](http://www.xuzhoujob.com/UpLoadFiles/editor/images/%E6%B1%82%E5%B7%A5%E4%BD%9C.jpg)


<!--more-->

### HTML
##### 1.img 的title和alt有什么区别?
  - 通常当鼠标滑动到元素上的时候显示
  - alt是img的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提高图片可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。

###### 2.从浏览器地址栏输入url到显示页面的步骤？
  - 浏览器根据请求的URL交给DNS域名解析。找到真实IP，向服务器发起请求；
  - 服务器交给后台处理完成后数据返回，浏览器接收文件（HTML、JS、CSS、图像等）；
  - 浏览器对加载到的资源（HTML、JS、CSS等） 进行语法解析，建立相应的内部数据结构（如HTML的DOM）；
  - 载入解析到的资源文件。渲染页面，完成。

##### 3.语义化的理解
  - 用正确的标签做正确的事情
  - HTML语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；
  - 在没有样式CSS的情况下也以一种文档格式显示，并且是容易阅读的。
  - 搜索引擎的爬虫依赖于标记来确定上下文的各个关键字的权重，利于SEO。
  - 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解

##### 4.介绍一下你对浏览器内核的理解？
  - 主要分为两部分：渲染引擎和js引擎
  - 渲染引擎： 负责取得网页的内容（HTML、XML、图像等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出在显示器或打印机上。浏览器的内核的不同对于网页的语伐解释会有所不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其他需要编辑、显示网络的内容的应用程序都需要内核。
  - js引擎： 解析和执行JavaScript来实现网页的动态效果
  - 最开始渲染引擎和js引擎并没有区分的很明确，后来js引擎越来越独立，内核就倾向于只指渲染引擎。

##### 5.html5有哪些新特性、移除了哪些元素？
  - HTML5现在已经不是SGML的子集，主要是关于图像，位置，存储，多任务等功能的增加
    - 绘画 canvas
    - 用于媒介回放的 video 和 audio 元素
    - 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失
    - sessionStorage 的数据在浏览器关闭后自动删除
    - 语义化更好的内容元素，比如article、footer、header、nav、section。
    - 表单控件，calendar、date、time、email、URL、search
    - 新的技术 webworker， websocket， Geolocation
  - 移除的元素：
    - 纯表现的元素： basefont，big，center，font，s，strike，tt，u`
    - 对可用性产生负面影响的元素Lframe ，frameset，noframes
  - 支持HTML5新标签
    - IE8/IE7/IE6 支持通过document.createElement 方法产生的标签
    - 可以利用这一特性让这些浏览器支持 HTML5新标签
    - 浏览器支持新标签后，还需要添加标签默认的样式

##### 6.HTML5的离线存储怎么使用,工作原理能不能解释一下？
  - 在用户没有与英特网链接时，可以正常访问站点或应用，在用户与英特网链接时，更新用户机器上的缓存文件
  - 原理： HTML5的离线存储是基于一个新建的 .appcache 文件的缓存机制（不是存储技术）， 通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示
  - 如何使用：
    - 页面头部像下面一样加入一个manifest的属性；
    - 在 cache.manifest 文件的编写离线存储的资源
    - 在离线状态时，操作 window.applicationCache 进行需求实现

##### 7.浏览器是怎么对HTML5的离线存储资源进行管理和加载的呢
  - 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问App，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过App并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储
  - 离线的情况下，浏览器就直接使用离线存储的资源。
##### 8.请描述一下cookie ，sessionStorage和localStorage的区别？
  - cookie是网站为了标示用户身份而存储在用户本地终端上的数据（通常经过加密）
  - cookie数据始终在同源的http请求中携带（即使不需要），即会在浏览器和服务器间来回传递
  - sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存
  - 存储大小
    - cookie数据大小不能超过4K
    - sessionStorage和localStorage虽然也有存储大小的限制，但是比cookie大得多，可以达到5M或更大
  - 有期时间：
    - localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据
    - sessionStorage数据在当前浏览器窗口关闭后自动删除
    - cookie 设置的cookie过期的时间之前一直有效，即使窗口或浏览器关闭

##### 9.iframe有哪些缺点
  - iframe会阻塞主页面的 onload 事件
  - 搜索引擎的检索程序无法解读这种页面，不利于SEO
  - iframe和主页面共享连接池，而浏览器对相同域的链接有限，所以会影响页面的并行加载
  - 使用iframe之前需要考虑这两点。如果需要使用iframe，最好是通过JavaScript动态给iframe添加src属性值，这样可以绕开以上两个问题

##### 10。WEB标准以及W3c标准是什么？
  - 标签闭合、标签小写、不乱嵌套、使用外链css和js、结构行为表现的分离

##### 11.xhtml和html有什么区别？
  - 一个是功能上的区别
    - 主要是XHTML可兼容各大浏览器、手机以及PDA，并且浏览器也能快速正确的编译网页
  - 另外是书写习惯的差别
    - XHTML元素必须被正确的嵌套，闭合，区分大小写，文档必须拥有根元素

##### 12.Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?
  - 页面被加载的时，link会同时被加载，而@imort页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载；import只在IE5以上才能识别，而link是XHTML标签，无兼容问题；link方式的样式的权重 高于@import的权重
  - <!DOCTYPE> 声明位于文档中的最前面，处于 html 标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档
  - 严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行
  - 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现

##### 17、行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？
  - 行内元素有：a b span img input select strong
  - 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p
  - 空元素：br> hr> img> input> link> meta>
  - 行内元素不可以设置宽高，不独占一行
  - 块级元素可以设置宽高，独占一行

##### 18. 页面导入样式时，使用link和@import有什么区别？
  - link属于XHTML标签，除了加载css外，还能用于定义RSS，定义rel链接属性等作用；而@import是css提供的，只能用于加载页面
  - 页面被加载时，link会同时被加载，而@import引入的CSS会等到页面被加载完再加载
  - import只有在IE5以上才能被识别，而link是XHTML标签，无兼容问题

##### 19. 如果需要手动写动画，你认为最小时间间隔是多久，为什么
  - 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms

#### 20. 什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）
  - 如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，
    所以不如隔离开。

  - 因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，
    这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。

  - 同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，
    提高了webserver的http请求的解析速度。

### SEO
##### 1.前端需要注意哪些SEO?
  - 合理的title、description、keywords：搜索对着三项的权证逐渐减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不过过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可；
  - 语义化的HTNL代码，符合W3C规范：语义化代码让搜索引擎容易理解网页
  - 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取
  - 重要内容不要用is输出： 爬虫不会执行js获取内容
  - 少用iframe：搜索引擎不会抓取iframe中的内容
  - 非装饰性图片必须加alt
  - 提高网站速度：网站速度是搜索引擎排序的一个重要指标

##### 2.如何进行网站性能优化？
  - content 方面
    - 减少HTTP请求：合并文件、CSS精灵、inline Image；
    - 减少DNS查询： DNS缓存、将资源分布到恰当数量的主机名；
    - 减少DNS元素数量
  - Server 方面
    - 使用CDN
    - 配置ETag
    - 对组件使用Gzip压缩
  - Cookie 方面
    - 减小cookie大小
  - css 方面
    - 将样式表放到页面顶部
    - 不使用CSS表达式
    - 使用 link 不使用 @import
  - JavaScript 方面
    - 将脚本放到页面底部
    - 将JavaScript和css从外部引入
    - 压缩JavaScript和css
    - 删除不需要的脚本
    - 减少DOM访问
  - 图片方面
    - 优化图片： 根据实际颜色需要选择色深、压缩
    - 优化css精灵
    - 不要在HTML中拉伸图片


### HTTP
##### 1.HTTP的几种请求方法用途
  - GET 方法
    - 发送一个请求来获取服务器上某一资源
  - POST 方法
    - 向URL指定的资源提交数据或附加新的数据
  - PUT 方法
    - 跟POST方法很像，也是向服务器提交数据。但是，它们之间有不同。PUt指定了资源在服务器上的位置，而POST没有
  - HEAD 方法
    - 只请求页面的首部
  - DELETE 方法
    - 删除服务器上的某资源
  - OPTIONS 方法
    - 它用于获取当前URL所支持的方法。如果请求成功，会有一个ALLow的头包含类似“ GET ，POST”这样的信息
  - TRACE 方法
    - TRACE方法被用于激发一个远程的，应用层的请求消息回路
  - CONNENT 方法
    - 把请求链接转换成透明的TCP/IP通道
##### 2.HTTP状态码及其含义
  - 1XX: 信息状态码
    - 100 Continue 继续，一般在发送post请求时，已发送了http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息
  - 2XX：成功状态码
    - 200 OK 正常返回信息
    - 201 Created 请求成功并且服务器创建了新的资源
    - 202 Accepted 服务器已接收请求，但尚未处理
  - 3XX：重定向
    - 301 Moved Permanently 请求的网页已永久移动到新的位置。
    - 302 Found 临时性重定向
    - 303 See Other 临时重定向，且总使用GET请求新的URL。
    - 304 NOT Modified 自从上次请求后，请求的网页未修改过。
  - 4XX： 客户端错误
    - 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
    - 401 Unauthorized 请求未授权。
    - 403 Forbidden 禁止访问
    - 404 Not Found 找不到如何与URL相匹配的资源
  - 5XX：服务器错误
    - 500 Internal Server Error 最常见的服务器端错误。
    - 503 Server Unavailable 服务器端暂时无法处理请求（可能是过载或维护）
    
### CSS
##### 1.css sprite是什么,有什么优缺点
  - 概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。
  - 优点：
    - 减少HTTP请求数，极大地提高页面加载速度
    - 增加图片信息重复度，提高压缩比，减少图片大小
    - 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现
  - 缺点：
    - 图片合并麻烦
    - 维护麻烦，修改一个图片可能需要从新布局整个图片，样式

##### 2.display: none;与visibility: hidden;的区别
  - 联系：它们都能让元素不可见
  - 区别：
    - display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见
    - display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式
    - 修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。
    - 读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容

##### 3、link与@import的区别
  - link是HTML方式， @import是CSS方式
  - link最大限度支持并行下载，@import过多嵌套导致串行下载，出现FOUC
  - link可以通过rel="alternate stylesheet"指定候选样式
  - 浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式
  - @import必须在样式规则之前，可以在css文件中引用其他文件
  - 总体来说：link优于@import

##### 4、什么是FOUC?如何避免
  - Flash Of Unstyled Content：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。
  - 解决方法：把样式表放到文档的head
##### 5. 如何创建块级格式化上下文(block formatting context),BFC有什么用
  - 创建规则：
    - 根元素
    - 浮动元素（float不是none）
    - 绝对定位元素（position取值为absolute或fixed）
    - display取值为inline-block,table-cell, table-caption,flex, inline-flex之一的元素
    - overflow不是visible的元素
  - 作用：
    - 可以包含浮动元素
    - 不被浮动元素覆盖
    - 阻止父子元素的margin折叠

##### 6.清除浮动的几种方式，各自的优缺点
  - 使用空标签清除浮动clear:both（缺点，增加无意义的标签）
  - 使用overflow:auto（使用zoom:1用于兼容IE，缺点：内部宽高超过父级div时，会出现滚动条）
  - 用afert伪元素清除浮动(IE8以上和非IE浏览器才支持，目前：大型网站都有使用

##### 7.为什么要初始化CSS样式?
  - 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。
  - 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化

##### 8.css3有哪些新特性
  - 新增各种css选择器
  - 圆角 border-radius
  - 多列布局
  - 阴影和反射
  - 文字特效text-shadow
  - 线性渐变
  - 旋转transform

##### 9.PNG、GIF、JPG的区别及如何选
  - GIF
    - 8位像素， 256色
    - 无损压缩
    - 支持简单的动画
    - 支持boolean透明
  - JPEG
    - 颜色仅限于256
    - 有损压缩
    - 可控制压缩质量
    - 不支持透明
    - 适合照片
  - PNG
    - 有PNG8和truecolor PNG
    - PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画
    - 适合图标、背景、按钮


### JS

##### 1. 闭包的理解 (https://blog.csdn.net/hj7jay/article/details/53925335)

你不仅仅应该了解闭包的机制，更应该了解闭包为什么很重要，以及能够很容易地回答出闭包的几种可能的应用场景

闭包在 JavaScript 中常用来实现对象数据的私有，在事件处理和回调函数中也常常会用到它，此外还有 偏函数应用（partial applications）和柯里化（currying） ，以及其他函数式编程模式。

闭包 是由函数引用其周边状态（ 词法环境 ）绑在一起形成的（封装）组合结构。在 JavaScript 中，闭包在 每个函数被创建时 形成。
这是基本原理，但为什么我们关心这些？实际上，由于闭包与它的词法环境绑在一起，因此 闭包让我们能够从一个函数内部访问其外部函数的作用域 。

要使用闭包，只需要简单地将一个函数定义在另一个函数内部，并将它暴露出来。要暴露一个函数，可以将它返回或者传给其他函数。

内部函数将能够访问到外部函数作用域中的变量，即使外部函数已经执行完毕。
###### 闭包的使用例子
闭包的用途之一是实现对象的私有数据。数据私有是让我们能够面向接口编程而不是面向实现编程的基础。而面向接口编程是一个重要的概念，有助于我们创建更加健壮的软件，因为实现细节比接口约定相对来说更加容易被改变。

“面向接口编程，别面向实现编程。” 设计模式：可复用面向对象软件的要素

在 JavaScript 中，闭包是用来实现数据私有的原生机制。当你使用闭包来实现数据私有时，被封装的变量只能在闭包容器函数作用域中使用。你无法绕过对象 被授权的方法 在外部访问这些数据。在 JavaScript 中，任何定义在闭包作用域下的公开方法才可以访问这些数据。例如：
```js
const getSecret = (secret) => {
  return {
    get: () => secret
};
```
在上面的例子里， get() 方法定义在 getSecret() 作用域下，这让它可以访问任何 getSecret() 中的变量，于是它就是一个被授权的方法。在这个例子里，它可以访问参数 secret 。

在函数式编程中，闭包经常用于偏函数应用和柯里化。为了说明这个，我们先定义一些概念：

函数应用：一个过程，指将参数传给一个函数，并获得它的返回值。

偏函数应用：一个过程，它传给某个函数其中一部分参数，然后返回一个新的函数，该函数等待接受后续参数。换句话说，偏函数应用是一个函数，它接受另一个函数为参数，这个作为参数的函数本身接受多个参数，它返回一个函数，这个函数与它的参数函数相比，接受更少的参数。偏函数应用 提前赋予 一部分参数，而返回的函数则等待调用时传入剩余的参数。

偏函数应用通过闭包作用域来提前赋予参数。你可以实现一个通用的函数来赋予指定的函数部分参数，

 - JS 的闭包包含以下要点：
    - 函数声明的时候，会生成一个独立的作用域
    - 同一作用域的对象可以互相访问
    - 作用域呈层级包含状态，形成作用域链，子作用域的对象可以访问父作用域的对象，反之不能；另外子作用域会使用最近的父作用域的对象

##### 2. JS 继承
  - 原型链继承
  ```js
  function xiyan(name) {
    this.name = name
  }
  xiyan.prototype.sister = function() {
    return this.name
    console.log('傻子)
  }
  /* xiyan.prototype = {
    sister: function() {
      return this.name
      console.log('傻子')
    }
  } */

  zhou.prototype = new xiyan('sister')

  zhou.prototype.sayName = function() {
    console.log('宙宙')
  }

  zhou.sister()
  zhou.sayName()
  ```
  - 类式继承 (略)
  - 组合式继承：前两种方式的结合(略)
  - 寄生组合式继承(略)
  - ES6 继承
  ```js
    class xiyan {
      constructor(name) {
        this.name = name
      }
      doSomething() {
        console.log('小姐姐不要我了')
      }
      sayName() {
        console.log('伤心')
      }
    }

    class Zhou extends xiyan {
      constructor(name, xiyanName) {
        super(xiyanName);
        this.name = name
      }
      sayName() {
        console.log('zhou:', this.name)
      }
    }

    const zhou = new Zhou('宙宙', '夕颜');
    zhou.sayName()
    zhou.doSomething()
  ```
##### 3. promise
  - promise: 是异步编程的一种解决方案，可以使异步代码看起来如同步般清晰易读，从而从回调地狱中解脱出来， promise是一个关联了执行任务的承诺，当你的任务完成时，会根据任务的成功与否，执行相关的操作。所以创建promise对象的时候，构造函数中需要传递一个函数类型的参数，来作为与此promise对象关联的任务。so promise构造函数定义 如下：
  ```js
  function Promise(resolver) {}
  ```

  - promise两个特点
    - 对象的状态不收外界影响， promise 对象的三种状态， 创建的promise对象处于pending状态，pending状态可以转换为fullfilled和rejected,只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态
      - pending promise对象处于等待状态
      - fullfilled 执行成功状态
      - rejected 执行失败状态
    - 一但状态改变，就不会再变 。 Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，能逆向转化，且转化过程只能有一次，即resolve或reject后你能再resolve和reject，即，如果你错过了它，再去监听是得不到结果的。
  - promise 用法
    - promise对象是一个 构造函数，用来生成promise实例；
    - promise 对象实例： 
    ```js
    var promise = new Promise( function(resolve, reject) {
      if (异步操作成功) {
        resolve(value);
      } else {
        reject(error)
      }
    })

    ```
    - Promise 构造函数接受一个函数做为参数，该函数的两个参数分别是resolve和reject，他们是两个函数，由JavaScript引擎提供，不用自己部署。
    - resolve函数的作用是， 将promise对象的状态从“pending”变为“resolved”，在一步操作成功时调用，并将异步操作的结果，作为参数传递出去；
    - reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从“pending”变为“rejected”),在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
    
    - promise实例生成后，可以用then方法分别指定resolve状态和rejected状态的回调函数
    ```js
    var p1 = new Promise(test)
    var p2 = p1.then(function (result) {
      console.log('成功:' + result)
    })
    var p3 = p2.catch (function (reason) {
      console.log('小姐姐不要我了', + reason)
    })

    // 变量<b>p1</b>是一个promise对象，它负责执行test函数。由于test函数在内部是异步执行的，当test函数执行成功时，我们告诉Promise对象：
  
    // 如果成功，执行这个函数

    P1.then( function (result) {
      console.log('成功:' + result)
    })

    // 当test函数执行失败时，我们告诉Promise对象

    P2.catch( function(reason) {
      console.log('小姐姐不要我了：' + reason)
    })

    // 串联起来就是

    new Promise(test).then( function (result) {
      console.log('成功：' + result)
    }).catch( function (reason) {
      console.log('小姐姐不要我了' + reason)
    })
    
    ```
    - 如果then方法返回的是一个新的Promise实例（不是原来那个Promise实例），因此可以采用链式写法，即then方法后面再调用另一个then方法
    ```js
      P1.then(function (json){
        return json;
      }).then(function(post){
        //...

      });
      //依次指定了两个回调函数，第一个回到函数完成以后会将返回结果作为参数，传入第二个回调函数。采用链式的then，可以指定一组按照次序调用的回调函数。这时前一个回调函数，有可能返回的还是一个promise对象(即有异步操作)，这时后一个回调函数，就会等待该promise对象的状态发生变化，才会被调用。
    ```
  - promise缺点 
    - 无法取消promise，一旦新建它就会立即执行无法中途取消；
    - 如果不设置回调函数， Promise内部抛出错误，不会反应到外部；
    - 当处于 pending 状态时，无法得知目前进展到那一阶段（刚开始还是即将完成）

##### 4. 作用域
  - JS没有块级作用域
    - 块级作用域： 任何一对花括号（｛和｝）中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。
  - var声明变量，以function来划分作用域（函数作用域），大括号“{}” 却限定不了var的作用域。用var声明的变量具有变量提升（declaration hoisting）的效果。
    - 函数作用域： 定义在函数中的参数和变量在函数外部是不可见的。
  - ES6里增加了一个let，可以在{}， if， for里声明。用法同var，但作用域限定在块级，let声明的变量不存在变量提升。
    - ES6规定，如果代码块中存在let，这个区块从一开始就形成了封闭作用域。凡是在声明之前就使用，就会报错。即在代码块内，在let声明之前使用变量都是不可用的。语法上有个术语叫“暂时性死区”（temporal dead zone），简称TDZ。当然TDZ并没有出现在ES规范里，它只是用来形象的描述。
  ##### 为什么需要块级作用域？
  1. ES5只有全局作用域和函数作用域，没有块级作用域，会带来以下问题：
    - 1) 变量提升导致内层变量可能会覆盖外层变量
    ```js
    var i = 5;
    function func() {
      console.log(i);
      if (true) {
        var i = 6;
      }
    }
    func();
    ```
    - 2) 用来计数的循环变量泄露为全局变量
    ```js
    for (var i = 0; i < 10; i++) {  
    	console.log(i);  
    }  
    console.log(i);
    ```
  2. ES6的块级作用域
    - ES6允许块级作用域的任意嵌套。外层作用域无法读取内层作用域的变量。
    ```js
    {{{{
      {let i = 6;}
      console.log(i);
    }}}}
    ```
    - 内层作用域可以定义外层作用域的同名变量。
    ```js
    {{{{
      let i = 5;
      {let i = 6;}
    }}}}
    ```
    - 块级作用域的出现使得立即执行函数不再需要。
      - 立即执行函数：
      ```js
      (function() {
        var i = 5;
      })();
      ```
      - 块级作用域：
      ```js
      {
        let i = 5;
      }
      ```
  3. 块级作用域与函数声明
    - ES5规定，函数只能在顶层作用域和函数作用域之外声明，不能在块级作用域中声明。
    ```js
    if (true) {
      function func() {}
    }
    try {
      function func() {}
    } catch {
    }
    // 上面两种函数声明在ES5中都是非法的，但是浏览器没有遵守这一规定，还是支持在块级作用域中声明函数，因此以上两种情况实际都能运行，不会报错；但是，在严格模式下，还是会报错。

    'use strict':
    if (true) {
      function func() {} 
    }

    ```
    - ES6引入了块级作用域，明确允许在块级作用域中声明函数。
    ```js
    'use strict':
    if (true) {
      function func() {}
    }
    // ES6还规定，在块级作用域中，函数声明的行为类似于let，在块级作用域之外不可引用。
    ```

  ##### ES6中，函数声明会提升到函数作用域的头部。
  ```js
  function func() {
    console.log('out');
  }
  (function() {
    if (false) {
      function func() {
        console.log(‘in’);
      }
    }
    func();
  })()
  // 在ES5中输出：in
  //  在ES6中输出：out
  //  但是，以上代码在Chrome中运行会报错，实际运行的是以下代码：
  function func() {	console.log(‘out’);}(function() {	var func = undefined;	if (false) {		function func() {			console.log(‘in’);		}	}	func();})()
  // 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数，若确实需要，也应该写成函数表达式，而不是函数声明语句。
  {
    let func= function func() {
      console.log(‘in’);
    };
  };

  // 注意：ES6的块级作用域允许声明函数只在使用大括号的情况下成立，如果未使用大括号，会报错。
  'use strict':
  if (true) {
    function func1() {} // 不报错
  }
  if (true)
    function func2() {} // 报错
  ```

### 函数声明和块级作用域
  ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。 ES6 
  引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
  
  为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。
  - 允许在块级作用域内声明函数。
  - 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
  - 同时，函数声明还会提升到所在的块级作用域的头部。
  
  注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。
  
  考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

##### 5. 谈谈This对象的理解。
  - this总是指向函数的直接调用者（而非间接调用者）；
  - 如果有new关键字，this指向new出来的那个对象；
  - 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window；
  - 1）在全局作用域下直接调用函数，this指向window
  - 2）对象函数调用，哪个对象调用就指向哪个对象
  - 3）使用 new 实例化对象，在构造函数中的this指向实例化对象。
  - 4）使用call或apply改变this的指向
1. 用于区分全局变量和局部变量，需要使用this
2. 返回函数当前的对象，看jquery1.8.3源码。
3. es6中新增了箭头函数，箭头函数与通过function声明的函数不同，它的this是使用的声明时上下文中的this.并且不可通过apply, call等改变